<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Veil — E2EE Ephemeral Chat (Firestore • iMessage UI)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    :root { --bg:#0b0b0c; --panel:#141416; --muted:#9aa0a6; --accent:#7A3E9D; --bubbleSelf:#2b2f33; --bubblePeer:#1f2937; --text:#f3f4f6; }
    html,body{ height:100%; }
    body{ font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--text); }
    .card{ background:var(--panel); border:1px solid #26272b; border-radius:16px; }
    .btn{ transition:.2s; }
    .btn-primary{ background:var(--accent); color:white; }
    .btn-primary:hover{ filter:brightness(1.05); }
    .btn-secondary{ background:#2b2f33; color:white; }
    .btn-secondary:hover{ filter:brightness(1.1); }
    .bubble{ max-width:70%; padding:.6rem .9rem; border-radius:18px; line-height:1.35; word-wrap:break-word; }
    .bubble-self{ background:var(--bubbleSelf); border-top-right-radius:6px; }
    .bubble-peer{ background:var(--bubblePeer); border-top-left-radius:6px; }
    .scroll-smooth{ scroll-behavior:smooth; }
    .disabled{ opacity:.6; pointer-events:none; }
  </style>
</head>
<body class="h-full">
  <div class="max-w-5xl mx-auto p-4 h-full">
    <!-- Auth / Onboarding -->
    <div id="auth-screen" class="card p-6 max-w-md mx-auto mt-10">
      <h1 class="text-3xl font-bold mb-6 text-center">Veil</h1>
      <p class="text-sm text-gray-400 mb-6 text-center">End-to-end encrypted • Ephemeral • No history</p>

      <!-- Toggle Tabs -->
      <div class="flex mb-6 border-b border-[#2b2c31]">
        <button id="tab-login" class="flex-1 py-2 text-center font-medium text-gray-400 hover:text-white">Log in</button>
        <button id="tab-signup" class="flex-1 py-2 text-center font-medium text-gray-400 hover:text-white">Sign up</button>
      </div>

      <div class="space-y-5">
        <!-- SIGNUP -->
        <form id="signup-form" class="space-y-3 hidden">
          <input id="signup-username" placeholder="Username" class="w-full p-3 rounded-md bg-[#1b1c1f] border border-[#2b2c31]" required />
          <input id="signup-password" type="password" placeholder="Password" class="w-full p-3 rounded-md bg-[#1b1c1f] border border-[#2b2c31]" required />
          <button id="signup-btn" class="btn btn-primary w-full py-3 rounded-md">Sign up</button>
          <p id="signup-error" class="text-rose-400 text-sm text-center"></p>
        </form>

        <!-- LOGIN -->
        <form id="login-form" class="space-y-3">
          <input id="login-username" placeholder="Username" class="w-full p-3 rounded-md bg-[#1b1c1f] border border-[#2b2c31]" required />
          <input id="login-password" type="password" placeholder="Password" class="w-full p-3 rounded-md bg-[#1b1c1f] border border-[#2b2c31]" required />
          <button id="login-btn" class="btn btn-primary w-full py-3 rounded-md">Log in</button>
          <p id="login-error" class="text-rose-400 text-sm text-center"></p>
        </form>
      </div>
    </div>

    <!-- Dashboard -->
    <div id="dash-screen" class="hidden grid md:grid-cols-3 gap-4 h-[90vh]">
      <div class="card p-4 flex flex-col">
        <div class="flex items-center justify-between mb-3">
          <div>
            <div class="text-sm text-gray-400">Signed in as</div>
            <div id="me-name" class="font-semibold"></div>
          </div>
          <button id="logout-btn" class="btn btn-secondary px-3 py-2 rounded-md">Logout</button>
        </div>
        <div class="mt-2">
          <label class="text-sm text-gray-400">Find user</label>
          <div class="flex gap-2 mt-2">
            <input id="search-user" class="flex-1 p-2.5 rounded-md bg-[#1b1c1f] border border-[#2b2c31]" placeholder="Exact username" />
            <button id="search-btn" class="btn btn-primary px-3 py-2 rounded-md disabled" disabled>Chat</button>
          </div>
          <div id="search-result" class="mt-2 text-sm"></div>
        </div>
        <div class="mt-4">
          <div class="text-sm text-gray-400 mb-1">Recent</div>
          <div id="recent-list" class="space-y-2 text-sm text-gray-300"></div>
        </div>
      </div>

      <!-- Chat panel -->
      <div class="card md:col-span-2 p-0 flex flex-col overflow-hidden">
        <div class="px-4 py-3 border-b border-[#2b2c31] flex items-center justify-between">
          <div>
            <div class="text-xs text-gray-400">Chatting with</div>
            <div id="peer-name" class="font-semibold"></div>
          </div>
          <div class="flex gap-2">
            <button id="leave-btn" class="btn btn-secondary px-3 py-2 rounded-md">Leave</button>
          </div>
        </div>
        <div id="log" class="flex-1 overflow-y-auto px-4 py-4 space-y-2 scroll-smooth"></div>
        <div class="p-3 border-t border-[#2b2c31]">
          <div class="flex items-end gap-2">
            <textarea id="composer" rows="1" placeholder="Message…" class="flex-1 bg-[#1b1c1f] border border-[#2b2c31] rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-purple-500 max-h-40"></textarea>
            <button id="send-btn" class="btn btn-primary px-4 py-2 rounded-lg disabled" disabled>Send</button>
          </div>
          <div id="typing" class="text-xs text-gray-400 mt-1 h-4"></div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // --- Minimal, Firestore-only, true E2EE, ephemeral transport ---
    const log = (...a)=>{ try{ console.log('[Veil]',...a);}catch{} };
    const err = (...a)=>{ try{ console.error('[Veil]',...a);}catch{} };

    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, getDocs, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAO6sKjbBKdWm3MXggc-Iliywxh7CwSKok",
      authDomain: "capsc-d160e.firebaseapp.com",
      projectId: "capsc-d160e",
      storageBucket: "capsc-d160e.firebasestorage.app",
      messagingSenderId: "1069210585933",
      appId: "1:1069210585933:web:54f05cf195caeea8320504",
      measurementId: "G-4957PFGHS2"
    };

    const APP_ID = 'veil-app';
    const ROOM_TTL_MIN = 5;              // auto-delete window
    const TYPING_IDLE_MS = 1500;         // typing indicator timeout

    let app, db, auth, me=null, roomId=null, unsubRoom=()=>{};
    let myECDH=null, sharedKey=null;     // crypto state

    // DOM
    const authScreen = document.getElementById('auth-screen');
    const dashScreen = document.getElementById('dash-screen');
    const meName = document.getElementById('me-name');
    const searchUser = document.getElementById('search-user');
    const searchBtn = document.getElementById('search-btn');
    const searchResult = document.getElementById('search-result');
    const recentList = document.getElementById('recent-list');
    const peerName = document.getElementById('peer-name');
    const leaveBtn = document.getElementById('leave-btn');
    const composer = document.getElementById('composer');
    const sendBtn = document.getElementById('send-btn');
    const logView = document.getElementById('log');
    const typingView = document.getElementById('typing');

    // Auth forms
    const suForm = document.getElementById('signup-form');
    const suU = document.getElementById('signup-username');
    const suP = document.getElementById('signup-password');
    const suErr = document.getElementById('signup-error');
    const liForm = document.getElementById('login-form');
    const liU = document.getElementById('login-username');
    const liP = document.getElementById('login-password');
    const liErr = document.getElementById('login-error');
    const logoutBtn = document.getElementById('logout-btn');

    // --- Init ---
    init();
    function showAuth(){ authScreen.classList.remove('hidden'); dashScreen.classList.add('hidden'); }
    function showDash(){ authScreen.classList.add('hidden'); dashScreen.classList.remove('hidden'); }

    async function init(){
      app = initializeApp(firebaseConfig);
      db = getFirestore(app);
      auth = getAuth(app);
      onAuthStateChanged(auth, async (u)=>{
        if (u){
          const uref = doc(db, `/artifacts/${APP_ID}/public/data/users`, u.uid);
          const snap = await getDoc(uref);
          if (!snap.exists()){ await signOut(auth); return; }
          me = { uid:u.uid, ...snap.data() };
          meName.textContent = me.username;
          searchBtn.disabled=false; searchBtn.classList.remove('disabled');
          showDash();
          renderRecents();
        } else {
          me=null; showAuth();
        }
      });

      // auth handlers
      suForm.addEventListener('submit', async (e)=>{
        e.preventDefault(); suErr.textContent='';
        const un = suU.value.trim(); const pw = suP.value.trim();
        if (un.length<3){ suErr.textContent='Username must be at least 3 chars'; return; }
        const q1 = query(collection(db, `/artifacts/${APP_ID}/public/data/users`), where('username','==', un));
        const s1 = await getDocs(q1); if (!s1.empty){ suErr.textContent='Username taken'; return; }
        const cred = await createUserWithEmailAndPassword(auth, `${un}@e2ee-chat.app`, pw);
        await setDoc(doc(db, `/artifacts/${APP_ID}/public/data/users`, cred.user.uid), { uid: cred.user.uid, username: un });
      });

      liForm.addEventListener('submit', async (e)=>{
        e.preventDefault(); liErr.textContent='';
        try { await signInWithEmailAndPassword(auth, `${liU.value.trim()}@e2ee-chat.app`, liP.value.trim()); }
        catch(_){ liErr.textContent='Invalid username or password'; }
      });

      logoutBtn.addEventListener('click', ()=> signOut(auth));

      // Search
      searchBtn.addEventListener('click', doSearch);
      searchUser.addEventListener('keyup', (e)=> e.key==='Enter' && doSearch());

      // Chat actions
      sendBtn.addEventListener('click', sendMessage);
      composer.addEventListener('input', handleTyping);
      leaveBtn.addEventListener('click', leaveRoom);

      // crypto readiness
      if (!window.isSecureContext){ alert('This app requires HTTPS for encryption (crypto.subtle). Host on https:// or localhost.'); }
    }

    function recentKey(){ return 'veil_recents'; }
    function getRecents(){ try{ return JSON.parse(localStorage.getItem(recentKey())||'[]'); }catch{ return []; } }
    function pushRecent(item){ let r = getRecents().filter(x=>x.uid!==item.uid); r.unshift(item); r=r.slice(0,6); localStorage.setItem(recentKey(), JSON.stringify(r)); }
    function renderRecents(){ const r = getRecents(); recentList.innerHTML = r.length? '' : '<div class="text-gray-500">No recent chats</div>'; r.forEach(x=>{ const el=document.createElement('div'); el.className='flex items-center justify-between bg-[#1b1c1f] p-2.5 rounded-md'; el.innerHTML = `<div>${x.username}</div><button class="btn btn-secondary px-2 py-1 rounded-md text-sm">Open</button>`; el.querySelector('button').addEventListener('click', ()=> startChatWithUid(x.uid, x.username)); recentList.appendChild(el); }); }

    async function doSearch(){
      if (!me) return showAuth();
      const uname = (searchUser.value||'').trim();
      searchResult.textContent='';
      if (!uname) return;
      if (uname === me.username){ searchResult.innerHTML='<span class="text-amber-400">You cannot chat with yourself.</span>'; return; }
      const q2 = query(collection(db, `/artifacts/${APP_ID}/public/data/users`), where('username','==', uname));
      const s2 = await getDocs(q2);
      if (s2.empty){ searchResult.innerHTML='<span class="text-rose-400">User not found.</span>'; return; }
      const rec = s2.docs[0].data();
      searchResult.innerHTML = `<div class="flex items-center justify-between bg-[#1b1c1f] p-2.5 rounded-md"><div>${rec.username}</div><button id="start-chat" class="btn btn-primary px-3 py-1.5 rounded-md">Chat</button></div>`;
      document.getElementById('start-chat').addEventListener('click', ()=> startChatWithUid(rec.uid, rec.username));
    }

    function roomFor(userA, userB){ return [userA, userB].sort().join('-'); }

    async function startChatWithUid(peerUid, peerUsername){
      if (!me) return showAuth();
      peerName.textContent = peerUsername;
      roomId = roomFor(me.username, peerUsername);
      const rref = doc(db, `/artifacts/${APP_ID}/public/data/e2ee-chat`, roomId);

      // init room if missing
      const rsnap = await getDoc(rref);
      if (!rsnap.exists()){
        await setDoc(rref, {
          participants: [me.uid, peerUid],
          usernames: [me.username, peerUsername].sort(),
          createdAt: serverTimestamp(),
          expiresAt: new Date(Date.now()+ROOM_TTL_MIN*60*1000),
          keys: {},
          buffers: {},   // ephemeral message buffers per uid
          typing: {},    // typing booleans per uid
          lastActive: serverTimestamp()
        });
      }

      // ECDH key exchange -> sharedKey
      await ensureSharedKey(rref, me.uid);

      // listener for peer buffer + typing
      if (unsubRoom) unsubRoom();
      unsubRoom = onSnapshot(rref, async (snap)=>{
        if (!snap.exists()) return;
        const data = snap.data();
        const otherUid = (data.participants||[]).find(x=>x!==me.uid);

        // show typing
        const isTyping = !!(data.typing && data.typing[otherUid]);
        typingView.textContent = isTyping? 'typing…' : '';

        // incoming message buffer from peer
        const payload = data.buffers && data.buffers[otherUid];
        if (payload && payload.c && payload.iv){
          const txt = await decryptPayload(payload);
          if (txt !== null) appendBubble('peer', txt);
          // clear peer buffer to keep no-history
          await updateDoc(rref, { [`buffers.${otherUid}`]: null, lastActive: serverTimestamp(), expiresAt: new Date(Date.now()+ROOM_TTL_MIN*60*1000) });
        }
      });

      // UI state
      composer.value=''; logView.innerHTML='';
      sendBtn.disabled=false; sendBtn.classList.remove('disabled');
      pushRecent({ uid: peerUid, username: peerUsername });
      renderRecents();
    }

    // --- E2EE helpers ---
    async function ensureSharedKey(roomRef, myUid){
      if (!window.isSecureContext) throw new Error('HTTPS required for crypto.subtle');
      if (!myECDH){ myECDH = await crypto.subtle.generateKey({ name:'ECDH', namedCurve:'P-256' }, true, ['deriveKey']); }
      const myPub = await crypto.subtle.exportKey('jwk', myECDH.publicKey);
      await updateDoc(roomRef, { [`keys.${myUid}`]: myPub, lastActive: serverTimestamp(), expiresAt: new Date(Date.now()+ROOM_TTL_MIN*60*1000) });

      const otherPub = await waitOtherKey(roomRef, myUid);
      const otherKey = await crypto.subtle.importKey('jwk', otherPub, { name:'ECDH', namedCurve:'P-256' }, true, []);
      sharedKey = await crypto.subtle.deriveKey({ name:'ECDH', public: otherKey }, myECDH.privateKey, { name:'AES-GCM', length:256 }, false, ['encrypt','decrypt']);
    }

    function waitOtherKey(roomRef, myUid){
      return new Promise((resolve, reject)=>{
        const stop = onSnapshot(roomRef, (s)=>{
          const d = s.data();
          if (!d || !d.keys) return;
          const other = Object.entries(d.keys).find(([k,_])=>k!==myUid);
          if (other){ stop(); resolve(other[1]); }
        }, (e)=>{ reject(e); });
        setTimeout(()=>{ try{ stop(); }catch{} reject(new Error('Peer key timeout')); }, 15000);
      });
    }

    async function encryptText(text){
      if (!sharedKey) return null;
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const pt = new TextEncoder().encode(text);
      const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, sharedKey, pt);
      return { c: btoa(String.fromCharCode(...new Uint8Array(ct))), iv: btoa(String.fromCharCode(...iv)), ts: Date.now() };
    }

    async function decryptPayload({c,iv}){
      try{
        if (!sharedKey) return null;
        const ct = Uint8Array.from(atob(c), ch=>ch.charCodeAt(0));
        const _iv = Uint8Array.from(atob(iv), ch=>ch.charCodeAt(0));
        const pt = await crypto.subtle.decrypt({ name:'AES-GCM', iv:_iv }, sharedKey, ct);
        return new TextDecoder().decode(pt);
      }catch(e){ err('decrypt failed', e); return null; }
    }

    // --- Chat UX ---
    let typingTimer=null;
    async function handleTyping(){
      if (!me || !roomId) return;
      const rref = doc(db, `/artifacts/${APP_ID}/public/data/e2ee-chat`, roomId);
      await updateDoc(rref, { [`typing.${me.uid}`]: true, lastActive: serverTimestamp() });
      if (typingTimer) clearTimeout(typingTimer);
      typingTimer = setTimeout(async ()=>{ try{ await updateDoc(rref, { [`typing.${me.uid}`]: false, lastActive: serverTimestamp() }); }catch{} }, TYPING_IDLE_MS);
    }

    async function sendMessage(){
      if (!me || !roomId) return;
      const text = composer.value.trim(); if (!text) return;
      appendBubble('self', text);
      composer.value='';
      const rref = doc(db, `/artifacts/${APP_ID}/public/data/e2ee-chat`, roomId);
      const enc = await encryptText(text); if (!enc) { alert('Encryption unavailable (HTTPS?).'); return; }
      // Put message into my buffer; peer will read & clear it
      await updateDoc(rref, { [`buffers.${me.uid}`]: enc, [`typing.${me.uid}`]: false, lastActive: serverTimestamp(), expiresAt: new Date(Date.now()+ROOM_TTL_MIN*60*1000) });
      // Immediately clear my own buffer (no server history for sender either)
      setTimeout(async ()=>{ try{ await updateDoc(rref, { [`buffers.${me.uid}`]: null, lastActive: serverTimestamp() }); }catch{} }, 500);
    }

    function appendBubble(role, text){
      const wrap = document.createElement('div');
      wrap.className = `w-full flex ${role==='self'? 'justify-end':''}`;
      const b = document.createElement('div');
      b.className = `bubble ${role==='self'? 'bubble-self':'bubble-peer'}`;
      b.textContent = text;
      wrap.appendChild(b); logView.appendChild(wrap); logView.scrollTop = logView.scrollHeight;
    }

    async function leaveRoom(){
      if (!roomId) return;
      const rref = doc(db, `/artifacts/${APP_ID}/public/data/e2ee-chat`, roomId);
      try{ await updateDoc(rref, { [`typing.${me.uid}`]: false, expiresAt: new Date(Date.now()+60*1000) }); }catch{}
      try{ unsubRoom&&unsubRoom(); }catch{}
      roomId=null; sharedKey=null; myECDH=null; peerName.textContent=''; logView.innerHTML=''; composer.value='';
      sendBtn.disabled=true; sendBtn.classList.add('disabled');
    }

    // --- Smoke tests (do not modify existing behavior) ---
    (async function tests(){
      try{
        // 1) AES-GCM roundtrip (independent of room) — ensures crypto works
        const t = 'hello-crypto';
        const kk = await crypto.subtle.generateKey({ name:'AES-GCM', length:256 }, true, ['encrypt','decrypt']);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, kk, new TextEncoder().encode(t));
        const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, kk, ct);
        if (new TextDecoder().decode(pt) !== t) throw new Error('AES roundtrip failed');
        log('TEST: AES-GCM roundtrip OK');

        // 2) UI no-crash without auth
        const before = authScreen.classList.contains('hidden');
        showAuth(); showDash(); // toggle ok
        if (typeof showAuth!== 'function' || typeof showDash !== 'function') throw new Error('UI funcs missing');
        if (before) showDash(); else showAuth();
        log('TEST: UI toggles OK');
      }catch(e){ err('Self-tests failed:', e); }
    })();

  </script>
</body>
</html>

<!--
FIRESTORE SECURITY RULES (paste in console -> Firestore Rules)
--------------------------------------------------------------
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function signedIn() { return request.auth != null; }
    function participant(room) { return signedIn() && room.data.participants.hasOnly([request.auth.uid]) == false && room.data.participants.hasAny([request.auth.uid]); }

    match /artifacts/{app}/public/data {
      match /users/{uid} {
        allow read: if signedIn();
        allow write: if signedIn() && request.auth.uid == uid;
      }
      match /e2ee-chat/{roomId} {
        allow create: if signedIn();
        allow read, update, delete: if signedIn() && participant(resource);
      }
    }
  }
}

TTL AUTO-DELETE
----------------
Enable TTL on field `expiresAt` for collection path:
  artifacts/veil-app/public/data/e2ee-chat
This UI bumps `expiresAt` on activity and shortens on leave.

NOTES
-----
- Firestore is used only as a transient transport. Messages are written to a per-user ephemeral `buffers` field and cleared immediately after peer consumption.
- End-to-end encryption via ECDH(P-256) -> AES-GCM(256). Only ciphertext + IV hit Firestore.
- No Realtime Database. Typing indicator uses Firestore's `typing` map.
- To truly minimize history, keep TTL small and do not enable backups/long-term retention.
-->
